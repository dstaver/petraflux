{"version":3,"sources":["../node_modules/loglevel/lib/loglevel.js","color.ts","index.ts"],"names":["root","definition","define","amd","module","exports","log","noop","undefinedType","isIE","window","test","navigator","userAgent","logMethods","bindMethod","obj","methodName","method","bind","Function","prototype","call","e","apply","arguments","traceForIE","console","trace","replaceLoggingMethods","level","loggerName","i","length","methodFactory","debug","defaultMethodFactory","realMethod","undefined","enableLoggingWhenConsoleArrives","Logger","name","defaultLevel","factory","self","currentLevel","storageKey","getPersistedLevel","storedLevel","localStorage","ignore","cookie","document","location","indexOf","encodeURIComponent","exec","slice","levels","getLevel","setLevel","persist","toUpperCase","SILENT","persistLevelIfPossible","levelNum","levelName","setDefaultLevel","enableAll","TRACE","disableAll","initialLevel","defaultLogger","_loggersByName","getLogger","TypeError","logger","_log","noConflict","getLoggers"],"mappings":"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AAO,GAAI,KAAO,IAEP,oBAAd,WACN,UAAU,WACV,qBAAqB,KAAK,UAAU,UAAU,gBA3EpD,QAAA,YAAA,EAmBA,QAAA,OAAA,EASA,QAAA,gBAAA,EAQA,QAAA,UAAA;;ACoFA,aAAA,IAAA,EAAA,MAAA,KAAA,iBAAA,SAAA,GAAA,OAAA,GAAA,EAAA,WAAA,EAAA,CAAA,QAAA,IAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAvIA,MAAA,EAAA,EAAA,QAAA,aAEA,EAAA,QAAA,WAeM,EAAkB,EAAA,QAAI,cAC5B,EAAA,QAAI,cAAgB,SAAS,EAAY,EAAU,GAC3C,MAAA,EAAY,EAAgB,EAAY,EAAU,GAClD,EAAc,EAAA,OAAO,EAAA,YAAY,IAChC,OAAA,SAAS,GACd,OACO,OAAgB,aACZ,iEACT,oFAIN,EAAA,QAAI,SAAS,EAAA,QAAI,YACjB,MAAM,EAAS,EAAA,QAAI,UAAU,WAC7B,EAAO,KAAK,wBACZ,MAAM,EAAW,CACf,YACA,SACA,QACA,UACA,gBACA,QACA,YACA,SACA,QACA,QACA,SACA,OACA,SACA,KACA,UACA,QACA,QACA,QACA,WACA,MACA,SACA,QACA,QACA,QACA,SACA,YACA,MACA,OACA,eACA,OACA,MACA,UACA,SACA,SACA,QACA,YACA,SACA,QACA,OACA,KACA,OACA,YACA,OACA,QACA,KACA,UACA,OACA,SACA,YACA,QACA,SACA,YACA,MACA,QACA,UACA,QACA,QACA,QACA,OACA,YACA,WACA,WACA,SACA,IACA,SACA,UACA,QACA,SACA,WACA,UACA,MACA,WACA,MACA,MACA,QACA,MACA,aACA,SACA,OACA,YACA,OACA,OACA,MACA,QACA,QACA,MACA,QACA,SACA,QACA,SACA,KACA,YACA,OACA,IACA,aACA,KACA,WACA,OACA,QACA,SAGF,EAAS,QAAQ,IACT,MAAA,EAAS,EAAA,QAAI,UAAU,GAC7B,EAAO,KAAK,uBACZ,EAAO,KAAK,uBACZ,EAAO,MAAM,uBACb,EAAO,MAAM,uBACb,EAAO,MAAM","file":"src.ba06ab52.js","sourceRoot":"../src","sourcesContent":["/*\n* loglevel - https://github.com/pimterry/loglevel\n*\n* Copyright (c) 2013 Tim Perry\n* Licensed under the MIT license.\n*/\n(function (root, definition) {\n    \"use strict\";\n    if (typeof define === 'function' && define.amd) {\n        define(definition);\n    } else if (typeof module === 'object' && module.exports) {\n        module.exports = definition();\n    } else {\n        root.log = definition();\n    }\n}(this, function () {\n    \"use strict\";\n\n    // Slightly dubious tricks to cut down minimized file size\n    var noop = function() {};\n    var undefinedType = \"undefined\";\n    var isIE = (typeof window !== undefinedType) && (\n        /Trident\\/|MSIE /.test(window.navigator.userAgent)\n    );\n\n    var logMethods = [\n        \"trace\",\n        \"debug\",\n        \"info\",\n        \"warn\",\n        \"error\"\n    ];\n\n    // Cross-browser bind equivalent that works at least back to IE6\n    function bindMethod(obj, methodName) {\n        var method = obj[methodName];\n        if (typeof method.bind === 'function') {\n            return method.bind(obj);\n        } else {\n            try {\n                return Function.prototype.bind.call(method, obj);\n            } catch (e) {\n                // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n                return function() {\n                    return Function.prototype.apply.apply(method, [obj, arguments]);\n                };\n            }\n        }\n    }\n\n    // Trace() doesn't print the message in IE, so for that case we need to wrap it\n    function traceForIE() {\n        if (console.log) {\n            if (console.log.apply) {\n                console.log.apply(console, arguments);\n            } else {\n                // In old IE, native console methods themselves don't have apply().\n                Function.prototype.apply.apply(console.log, [console, arguments]);\n            }\n        }\n        if (console.trace) console.trace();\n    }\n\n    // Build the best logging method possible for this env\n    // Wherever possible we want to bind, not wrap, to preserve stack traces\n    function realMethod(methodName) {\n        if (methodName === 'debug') {\n            methodName = 'log';\n        }\n\n        if (typeof console === undefinedType) {\n            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\n        } else if (methodName === 'trace' && isIE) {\n            return traceForIE;\n        } else if (console[methodName] !== undefined) {\n            return bindMethod(console, methodName);\n        } else if (console.log !== undefined) {\n            return bindMethod(console, 'log');\n        } else {\n            return noop;\n        }\n    }\n\n    // These private functions always need `this` to be set properly\n\n    function replaceLoggingMethods(level, loggerName) {\n        /*jshint validthis:true */\n        for (var i = 0; i < logMethods.length; i++) {\n            var methodName = logMethods[i];\n            this[methodName] = (i < level) ?\n                noop :\n                this.methodFactory(methodName, level, loggerName);\n        }\n\n        // Define log.log as an alias for log.debug\n        this.log = this.debug;\n    }\n\n    // In old IE versions, the console isn't present until you first open it.\n    // We build realMethod() replacements here that regenerate logging methods\n    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {\n        return function () {\n            if (typeof console !== undefinedType) {\n                replaceLoggingMethods.call(this, level, loggerName);\n                this[methodName].apply(this, arguments);\n            }\n        };\n    }\n\n    // By default, we use closely bound real methods wherever possible, and\n    // otherwise we wait for a console to appear, and then try again.\n    function defaultMethodFactory(methodName, level, loggerName) {\n        /*jshint validthis:true */\n        return realMethod(methodName) ||\n               enableLoggingWhenConsoleArrives.apply(this, arguments);\n    }\n\n    function Logger(name, defaultLevel, factory) {\n      var self = this;\n      var currentLevel;\n      var storageKey = \"loglevel\";\n      if (name) {\n        storageKey += \":\" + name;\n      }\n\n      function persistLevelIfPossible(levelNum) {\n          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();\n\n          if (typeof window === undefinedType) return;\n\n          // Use localStorage if available\n          try {\n              window.localStorage[storageKey] = levelName;\n              return;\n          } catch (ignore) {}\n\n          // Use session cookie as fallback\n          try {\n              window.document.cookie =\n                encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\n          } catch (ignore) {}\n      }\n\n      function getPersistedLevel() {\n          var storedLevel;\n\n          if (typeof window === undefinedType) return;\n\n          try {\n              storedLevel = window.localStorage[storageKey];\n          } catch (ignore) {}\n\n          // Fallback to cookies if local storage gives us nothing\n          if (typeof storedLevel === undefinedType) {\n              try {\n                  var cookie = window.document.cookie;\n                  var location = cookie.indexOf(\n                      encodeURIComponent(storageKey) + \"=\");\n                  if (location !== -1) {\n                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];\n                  }\n              } catch (ignore) {}\n          }\n\n          // If the stored level is not valid, treat it as if nothing was stored.\n          if (self.levels[storedLevel] === undefined) {\n              storedLevel = undefined;\n          }\n\n          return storedLevel;\n      }\n\n      /*\n       *\n       * Public logger API - see https://github.com/pimterry/loglevel for details\n       *\n       */\n\n      self.name = name;\n\n      self.levels = { \"TRACE\": 0, \"DEBUG\": 1, \"INFO\": 2, \"WARN\": 3,\n          \"ERROR\": 4, \"SILENT\": 5};\n\n      self.methodFactory = factory || defaultMethodFactory;\n\n      self.getLevel = function () {\n          return currentLevel;\n      };\n\n      self.setLevel = function (level, persist) {\n          if (typeof level === \"string\" && self.levels[level.toUpperCase()] !== undefined) {\n              level = self.levels[level.toUpperCase()];\n          }\n          if (typeof level === \"number\" && level >= 0 && level <= self.levels.SILENT) {\n              currentLevel = level;\n              if (persist !== false) {  // defaults to true\n                  persistLevelIfPossible(level);\n              }\n              replaceLoggingMethods.call(self, level, name);\n              if (typeof console === undefinedType && level < self.levels.SILENT) {\n                  return \"No console available for logging\";\n              }\n          } else {\n              throw \"log.setLevel() called with invalid level: \" + level;\n          }\n      };\n\n      self.setDefaultLevel = function (level) {\n          if (!getPersistedLevel()) {\n              self.setLevel(level, false);\n          }\n      };\n\n      self.enableAll = function(persist) {\n          self.setLevel(self.levels.TRACE, persist);\n      };\n\n      self.disableAll = function(persist) {\n          self.setLevel(self.levels.SILENT, persist);\n      };\n\n      // Initialize with the right level\n      var initialLevel = getPersistedLevel();\n      if (initialLevel == null) {\n          initialLevel = defaultLevel == null ? \"WARN\" : defaultLevel;\n      }\n      self.setLevel(initialLevel, false);\n    }\n\n    /*\n     *\n     * Top-level API\n     *\n     */\n\n    var defaultLogger = new Logger();\n\n    var _loggersByName = {};\n    defaultLogger.getLogger = function getLogger(name) {\n        if (typeof name !== \"string\" || name === \"\") {\n          throw new TypeError(\"You must supply a name when creating a logger.\");\n        }\n\n        var logger = _loggersByName[name];\n        if (!logger) {\n          logger = _loggersByName[name] = new Logger(\n            name, defaultLogger.getLevel(), defaultLogger.methodFactory);\n        }\n        return logger;\n    };\n\n    // Grab the current global log variable in case of overwrite\n    var _log = (typeof window !== undefinedType) ? window.log : undefined;\n    defaultLogger.noConflict = function() {\n        if (typeof window !== undefinedType &&\n               window.log === defaultLogger) {\n            window.log = _log;\n        }\n\n        return defaultLogger;\n    };\n\n    defaultLogger.getLoggers = function getLoggers() {\n        return _loggersByName;\n    };\n\n    return defaultLogger;\n}));\n","interface Window {\n  process?: {\n    type: string\n  }\n}\nexport const colorSupport = useColors()\n\nconst prefixes: string[] = []\n\nexport type HslArray = [number, number, number]\n/**\n * Select a color.\n * @param {string} prefix Prefix to create color for\n * @return {array} [H, S, L] color array\n */\nexport function selectColor(prefix: string): HslArray {\n  let index = prefixes.indexOf(prefix)\n  if (index === -1) {\n    index = prefixes.push(prefix)\n  }\n  const increment = 24\n  const row = Math.floor((index * increment) / 255)\n  const alt = index % 2 ? 0 : 128\n  const h = index * increment + row * 4 + alt\n  const s = 100\n  const l = 70\n  return [h, s, l]\n}\n\n/**\n * Convert HSL array to hsl() string usable as a CSS color value\n * @param {array} hslArray [H, S, L] Color array\n * @returns {string} hsl() string\n */\nexport function hslStr(hslArray: HslArray): string {\n  return `hsl(${hslArray[0]},${hslArray[1]}%,${hslArray[2]}%)`\n}\n\n/**\n * Create a light background color from a color made by selectColor()\n * @param {array} hslArray HSL color to create beckground for\n * @returns {array} [H, S, L] Color array\n */\nexport function backgroundColor(hslArray: HslArray): HslArray {\n  return [hslArray[0], hslArray[1], 94]\n}\n\n/**\n * Check if current browser supports console color styling\n * @returns True if colors are supported\n */\nexport function useColors(): boolean {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (\n    typeof window !== 'undefined' &&\n    window.process &&\n    window.process.type === 'renderer'\n  ) {\n    return true\n  }\n\n  const userAgent =\n    (typeof navigator !== 'undefined' && String(navigator.userAgent)) || ''\n\n  // Internet Explorer and Edge do not support colors.\n  if (/(edge|trident)/.test(userAgent)) {\n    return false\n  }\n\n  // Is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return (\n    (typeof document !== 'undefined' &&\n      document.documentElement &&\n      document.documentElement.style &&\n      document.documentElement.style.webkitAppearance) ||\n    // Is firebug? http://stackoverflow.com/a/398120/376773\n    (typeof window !== 'undefined' &&\n      window.console &&\n      (window.console as any).firebug) ||\n    (window.console.exception && window.console.table) ||\n    // Is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (/firefox\\/(\\d+)/.test(navigator.userAgent.toLowerCase()) &&\n      parseInt(RegExp.$1, 10) >= 31) ||\n    // Double check webkit in userAgent just in case we are in a worker\n    (typeof navigator !== 'undefined' &&\n      navigator.userAgent &&\n      /applewebkit\\/(\\d+)/.test(navigator.userAgent.toLowerCase()))\n  )\n}\n","import log from 'loglevel'\n// import prefix from 'loglevel-plugin-prefix'\nimport { selectColor, hslStr } from './color'\n\n// prefix.reg(log)\n// prefix.apply(log, {\n//   template: '%c%n%c',\n//   levelFormatter(level) {\n//     return level.substr(0, 1)\n//   },\n//   nameFormatter(name) {\n//     return `${(name || 'global').toLowerCase()}`\n//   },\n//   timestampFormatter(date) {\n//     return date.toISOString()\n//   },\n// })\nconst originalFactory = log.methodFactory\nlog.methodFactory = function(methodName, logLevel, loggerName) {\n  const rawMethod = originalFactory(methodName, logLevel, loggerName)\n  const prefixColor = hslStr(selectColor(loggerName))\n  return function(message) {\n    rawMethod(\n      `%c${loggerName}%c ${message}`,\n      `color:${prefixColor};background:rgba(0,0,0,0.5);padding:4px 8px;border-radius:6px`,\n      'font-size:unset;color:unset;background:unset;padding:unset;border-radius:unset'\n    )\n  }\n}\nlog.setLevel(log.getLevel())\nconst logger = log.getLogger('logger1')\nlogger.info('Message from logger1')\nconst prefixes = [\n  'tristique',\n  'Aenean',\n  'Fusce',\n  'ligula.',\n  'pellentesque.',\n  'Morbi',\n  'elementum',\n  'lacus.',\n  'pede,',\n  'ipsum',\n  'Aenean',\n  'pede',\n  'tempus',\n  'mi',\n  'lectus.',\n  'eget,',\n  'Proin',\n  'lorem',\n  'aliquet,',\n  'in,',\n  'lectus',\n  'netus',\n  'arcu.',\n  'magna',\n  'auctor',\n  'Curabitur',\n  'non',\n  'nunc',\n  'ullamcorper.',\n  'arcu',\n  'sem',\n  'feugiat',\n  'metus.',\n  'aptent',\n  'orci.',\n  'volutpat.',\n  'risus.',\n  'Etiam',\n  'non,',\n  'eu',\n  'non,',\n  'dignissim',\n  'pede',\n  'dolor',\n  'eu',\n  'mauris.',\n  'Duis',\n  'ornare',\n  'porttitor',\n  'risus',\n  'dictum',\n  'penatibus',\n  'Sed',\n  'nunc.',\n  'aliquet',\n  'dolor',\n  'Nulla',\n  'eros.',\n  'Duis',\n  'hendrerit',\n  'egestas,',\n  'pharetra',\n  'tempor',\n  'a',\n  'lacus.',\n  'cubilia',\n  'lacus',\n  'dolor,',\n  'molestie',\n  'aliquet',\n  'per',\n  'egestas.',\n  'vel',\n  'non',\n  'vitae',\n  'at,',\n  'facilisis.',\n  'turpis',\n  'non,',\n  'fringilla',\n  'elit',\n  'amet',\n  'nec',\n  'Donec',\n  'Class',\n  'sit',\n  'lorem',\n  'justo.',\n  'nibh.',\n  'Nullam',\n  'id',\n  'placerat,',\n  'diam',\n  'a',\n  'vestibulum',\n  'eu',\n  'egestas.',\n  'nisi',\n  'Donec',\n  'velit',\n]\n\nprefixes.forEach(str => {\n  const logger = log.getLogger(str)\n  logger.info(`Message from logger`)\n  logger.warn(`Message from logger`)\n  logger.error(`Message from logger`)\n  logger.trace(`Message from logger`)\n  logger.debug(`Message from logger`)\n})\n"]}